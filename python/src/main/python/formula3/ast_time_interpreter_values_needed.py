import AST

import utils.utils as util
from formula3.exceptions.exception import Formula3Exception
import formula3.utils.SLF4J2PyLogging

try:
    from at.ac.ait.enviro.tsapi.timeseries import TimeSeries
except ImportError:
    print "Unable to import TimeSeries from java"
    from formula3.PythonTimeSeries import TimeSeries

try:
    from at.ac.ait.enviro.tsapi.timeseries import TimeStamp
except ImportError:
    print "Unable to import TimeStamps from java"
    from formula3.PythonTimeStamp import TimeStamp
    
try:
    from at.ac.ait.enviro.tsapi.timeseries import TimeInterval
except ImportError:
    print "Unable to import TimeInterval from Java"
    from formula3.PythonTimeInterval import TimeInterval


logger=formula3.utils.SLF4J2PyLogging.getLogger("AST_values_needed_Interpreter")

class SlotContainer():
    '''container for a TimeStamp and a dictionary representing a slot'''
    
    def __init__(self, timeStamp=None, slot={}, valueKey=None):
        self.timeStamp = timeStamp
        self.slot = slot
        self.valueKey = valueKey

    
        
def interprete(tsNode, timeStampList, timepattern, ast):
    ''' 
    @param tsNode: AST node of the time interval        
    @param timeStampList: list with TimeStamps of the current TimeInterval
    @param time: time pattern
    @return: a dictionary with the needed time interval for each ts id 
    '''
    
    ntime = util.normalizeTimePattern(timepattern)  # This is the "every xxx @ " information from the formula

    zeroOffset=(0, 'ms')
        
    # step 1: find all values in query range. This defines the timepattern (it's borders) of the interval we want to evaluate 
    leftBorder=timeStampList[0].asMilis()
    rightBorder=timeStampList[1].asMilis()
    
    startValue = util.findHighTimeStamp(ntime, zeroOffset, leftBorder)
    endValue = util.findLowTimeStamp(ntime, zeroOffset, rightBorder)
    
    tss = util.createTimeSeriesList(tsNode) # Find all time series in the expression
    
    all_ts_needed=[]
    
    for ts in tss:
        id=ts['id']
        interval = ts['interval']
        left_offset = interval['left']['offset']
        right_offset = interval['right']['offset']
        left_offset = util.normalizeTimeValue(left_offset)
        right_offset= util.normalizeTimeValue(right_offset)

        # step 2: Apply the offsets from the slice, i.e. the "A[t-1min .. t+10 secs]"
        startShifted=startValue+left_offset[0]
        endShifted=endValue+right_offset[0]
        this_ts_needed=(id, startShifted, endShifted)

        all_ts_needed.append(this_ts_needed)

    # The next step here is to sort out duplicate ID's and join the informations
    # This can arise from formulas like < A[t - 1 min .. t + 1 sec ] + A[t + 10hours] >

    all_ts_joined=dict()
    for ts_needed in all_ts_needed:
        id=ts_needed[0]
        if id in all_ts_joined:
            ts_previous=all_ts_joined[id]
            old_min=ts_previous[0]
            old_max=ts_previous[1]
        else:
            old_min=ts_needed[1]
            old_max=ts_needed[2]

        new_min=min(ts_needed[1], old_min)
        new_max=max(ts_needed[2], old_max)
        all_ts_joined[id]=(new_min, new_max)
    
    
    result = dict()
    
    for id, ts_needed in all_ts_joined.items():
        leftMost=ts_needed[0]
        rightMost=ts_needed[1]
        left_time_stamp = TimeStamp(leftMost)
        right_time_stamp = TimeStamp(rightMost)
        ti=TimeInterval(TimeInterval.Openness.CLOSED, left_time_stamp, right_time_stamp, TimeInterval.Openness.CLOSED)
        result[id]=ti
    
    return result 


class AST_Upstream_Time_Interpreter():
    '''
    Time interpreter for upstream time aspects in AST generated by the AST_Parser
    '''

    def __init__(self):
        '''
        Constructor
        '''
        
    def evaluate(self, ast, time_interval):
        '''
        Find the needed TimeInterval from initial interval
        @param ast: Abstract Syntax Tree from parsed expression
        @param time_interval: TimeInterval instance where values have changed
        @return: TimeInterval instance where update needed
        '''

        generator = ast['generators'][0]    # This is not a good idea for a longer time
        expression = generator['expressions'][0]
        every = generator['every']
        
        if every==None:
            tss = util.createTimeSeriesList(expression) # Find all time series in the expression
            result=dict()
            for ts in tss:  # Will take all TS' found in the expression. At least this is predictably wrong
                            # This is typically the case with logical splicing.
                            # This will break when "every" is allowed with logical slicing
                            # This will also break when there is more than one slice of the same TS in the generator 
                            # and it behaves not nice when there is an offset at the n   
                            # A better solution is pending        
                id=ts["id"]
                result[id]=time_interval
            
            return result
                          
        start=time_interval.getStart()
        end=time_interval.getEnd()
        return interprete(expression, (start, end), every, ast)
    
