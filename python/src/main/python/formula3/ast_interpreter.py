import copy
import formula3.globals
import formula3.AST as AST
import formula3.utils.utils as utils
from formula3.exceptions.exception import Formula3Exception
import formula3.utils.SLF4J2PyLogging
import re

try:
    from at.ac.ait.enviro.tsapi.timeseries import TimeStamp
except ImportError:
    print "Unable to import TimeStamps from java"
    from formula3.PythonTimeStamp import TimeStamp

try:
    from at.ac.ait.enviro.tsapi.timeseries import TimeInterval
except ImportError:
    from formula3.PythonTimeInterval import TimeInterval

try:
    from at.ac.ait.enviro.tsapi.timeseries import TimeSeries
except ImportError:
    from formula3.PythonTimeSeries import TimeSeries


logger=formula3.utils.SLF4J2PyLogging.getLogger("AST_Interpreter")


class abortSlotCalculationException():
    '''This class (an instance of, of course) is thrown, when the calculation of a class is to be aborted in an inner loop'''
    def __init__(self):
        pass
    

class AST_Interpreter():
    '''
    Standard interpreter for the AST generated by the AST_Parser
    '''

    logger=formula3.utils.SLF4J2PyLogging.getLogger("AST_Interpreter")

    def __init__(self):
        '''
        Constructor
        '''
        self.logger=None

        
    def calc_aggregate(self, tsSlice, valueKey, aggregate_name, t, TS):
    
        if self.logger!=None:
            self.logger.debug("Calculating an aggregate of name "+aggregate_name+" over a slice of length "+str(len(tsSlice)))
    
        if not aggregate_name in formula3.globals.aggregates:
            if self.logger!=None:
                self.logger.error('Unsupported aggregate '+aggregate_name)
            raise Formula3Exception('Unsupported aggregate '+aggregate_name)
        
        operator = formula3.globals.aggregates[aggregate_name]
        
        result=operator.calc((tsSlice, valueKey, t, TS))
    
        return result



    
    def op_generator(self, node, tssDic, tsClass):
        '''
        "generator" processing:
            
        '''
        
        baseTSNodeName = utils.findFirstTSName(node)    # This TS governs the time pattern of the output. This is a pragmatic approach until we find something different
        
        everyInfo=node["every"]
        if everyInfo==None:
            return self.op_generate(node, tssDic, baseTSNodeName, tsClass, True)   # Calculate a node based on the time pattern of the every clause
        else:
            return self.op_generate(node, tssDic, baseTSNodeName, tsClass, False)   # Calculate a node based on the time pattern of the base TS


    def op_generate(self, node, tssDic, baseTSName, resultTS, logical):
        '''
        Time series generator
        '''    
        
        # This is the chosen strategy: 
        # Iterate along the controlling time series. Each slot defines one result in the resulting TS
        # For each slot:
        #      calculate the inner nodes needed for the current result step (splice)
        

        baseTS=tssDic[baseTSName]
        tsNodeList = utils.createTimeSeriesList(node)    # This is the base information for splicing and for time creation    
        
        if logical:
            timeStampList = baseTS.getTimeStampsArray()    # A list of all timestamps from the base TS. We will iterate over this list
        else:
            everyInfo=node["every"]
            everyInfo=utils.normalizeTimePattern(everyInfo)
            
            baseTSNode=tsNodeList[0]    # Assuming we have at least one such node. Is this true in any case?
            sliceInfo=baseTSNode["interval"] # This must be a physical info
    
            leftInfo=sliceInfo["left"]   # nobody assures here that left is smaller than right, right? We'll cross that bridge when we come to it
            leftOffset=leftInfo["offset"]
            leftOffset=utils.normalizeTimeValue(leftOffset) # This should go into the parser (or the checker?) so it's done only once. Currently it's done here and during slicing
    
            rightInfo=sliceInfo["right"]
            rightOffset=rightInfo["offset"]
            rightOffset=utils.normalizeTimeValue(rightOffset)
    
            (firstTS, lastTS)=utils.getTSInterval(baseTS) # This should be a sample from all time series but taking the first will do for a few weeks
            
            if firstTS==None or lastTS==None: # No data at all and no information about a query interval...
                return resultTS
            
            timeStampListInt=utils.materializeTimePattern(everyInfo, leftOffset, rightOffset, firstTS.asMilis(), lastTS.asMilis())
            # just another inductivity adaption: This utility gives back int's; we need time stamps
            timeStampList=[]
            for tsInt in timeStampListInt:
                ts=TimeStamp(tsInt)
                timeStampList.append(ts)
        
        sliceDic  = {}                                 # This will hold the slices for the current iteration TODO: remove me
        
        for n,t in  enumerate(timeStampList): # Now iterate over all slots of the controlling time series
            resultSlot={}             # This is where the final result will be stored.
#            for tsNode in tsNodeList:                  # Make the slices and calc the aggregate for each mean
#                timeSeriesNameInFocus=tsNode["id"] # We are going to slice a section out of THIS
#                timeSeriesInFocus=tssDic[timeSeriesNameInFocus] # And this is what's behind a name
#                if logical:
#                    (slice, valueKey) = self.logic_slice(tsNode, timeStampList, timeSeriesInFocus, n)
#                else:
#                    (slice, valueKey) = self.physical_slice(tsNode, timeSeriesInFocus, t, leftInfo, rightInfo)   # This can be optimized by preparing the nodes to have normalized offset info
                
#                aggregate_name=tsNode["aggregate"]
#                aggregate_name=''
#                if aggregate_name!='': # There is an aggregate
#                    aggregate = self.calc_aggregate(slice, valueKey, aggregate_name, t, baseTS)
#                elif tsNode[AST.TYPE]=="PROPCOPY":
#                    if len(slice)>0:
#                        aggregate=slice[0].slot # We take the first slot out of the slice to have some extra data. I am not happy here. This should be more straight forward. But it will work for now
#                    else:
#                        aggregate={}    # A weak substitute for good data
#                else:
#                    aggregate=self.calc_aggregate(slice, valueKey, "None", t, baseTS)
                                    
#                
#                if tsNode[AST.TYPE]==AST.TYPE_SLICE:
#                    sliceInfo=tsNode["interval"]
#                    sliceName=timeSeriesNameInFocus+utils.intervalDescFromAST(sliceInfo)
#                else:
#                    sliceName=timeSeriesNameInFocus+"/PROPCOPY"
#                sliceDic[sliceName] = aggregate
                
            
            if resultSlot==None: # no proper result slot found. This is the case when the slicing has tried to get a slice outside the input range of timestamps (like accessing n+1 at the end of the iteration)
                                 # in this case do not write the slot
                continue
                
            expressionList=node["expressions"] # The list of all expressions (separated by semicolon in the f3 string)
            try:
                for expressionInfo in expressionList: 
                    expression=expressionInfo[0]
                    assignName=expressionInfo[1]
                    
                    result = self.evalTree(expression, timeStampList, tssDic, n, t, sliceDic)    # Result is either a dict (then no assignment is needed) or a skalar type

                    if result==None:
                        raise abortSlotCalculationException()    # No slot written when the result is none. Is that smart?

                    if isinstance(result, tuple) and isinstance(result[0], list):  # We got back a slice. That's something we can't deal with.
                        raise Formula3Exception("Expression gave back a slice as result. That's not feasible.")

                    if isinstance(result, tuple): # it MUST be a slot
                        # we do assign directly if there is no explicit assign name
                        if assignName==None:
                            result=result[0]    # is a dict now
                            utils.updateDictDecently(resultSlot, result, None)
                            result=None # Mark it as processed
                        else:
                            # break it down to a base type
                            vk=result[1]
                            result=result[0]
                            result=result[vk]
                            
                    if assignName==None and result!=None:   # We still need an assignment name
                        baseTSNode=utils.findFirstTS(expression)    # if nothing else specified we store the result in the same key as the property of the first TS involved
                        timeSeriesName=baseTSNode["id"]
                        timeSeriesAccessed=tssDic[timeSeriesName]
                        assignName=utils.getValueKey(baseTSNode, timeSeriesAccessed)  # Note ,that this shouldn't be called for a propcopy operator. But the procopy op should return a dict anyway.
                        
                    
                    if isinstance(result, (int, float, str, unicode)):    # is this list complete? if not, enhance it.
                            utils.updateDictDecently(resultSlot, result, assignName) # This is how things should work
                    elif result==None:
                        pass
                    else:
                        raise Formula3Exception("Expression returned an illegal construct: " + str(result))
                    
                utils.setSlot(resultTS, resultSlot, timeStampList[n])
                
            except abortSlotCalculationException:
                pass    # Just used to break free of an inner loop
            
        # The following line is a bad hack to come around the fact that an empty time series as input will not construct any valid values keys at all
        valueKeys=resultTS.getTSProperty(TimeSeries.VALUE_KEYS)
        if len(valueKeys)==0:
            valueKeys.append("NoKeysSet")
        resultTS.setTSProperty(TimeSeries.VALUE_KEYS, valueKeys)
        return resultTS




    
    def getCurrentIndex(self, n, boundarySide):
        ''' Returns if the current index value for a given 'n'  '''
        if not isinstance(boundarySide, dict):
            raise Exception('Invalid boundary object: '+`boundarySide`)     
    
        if len(boundarySide)!=2:
            raise Exception('Invalid boundary object: '+`boundarySide`)     
        
        offset=boundarySide["offset"]
        index=n+offset
        return index


        
    def logic_slice(self, tsNode, timeStampList, ts, n):
        ''' 
        Creates a slice from a TimeSeries with "logical" boundaries ('n')
        @param tsNode: AST node of the TimeSeries        
        @param timeStampList: list with TimeStamps of the current TimeSeries
        @param ts: TimeSeries object
        @param n: current "n"
        '''
        
        nodeType=tsNode[AST.TYPE]
        resultSlice = []

        if nodeType==AST.TYPE_SLICE:        
            boundary = utils.getBoundary(tsNode)
            valueKey = utils.getValueKey(tsNode, ts)
        elif nodeType=="PROPCOPY":
            boundary = {'type': AST.SLICE_TYPE_LOGICAL, 'left': {'type': 'CLOSED', 'offset': 0}, 'right': {'type': 'CLOSED', 'offset': 0} }  # Construct a slice as [n]
            valueKey="who cares"    # Would be interesting when the first crazy mind comes by who reserves a value key like this :-)
        
        if utils.isNumTS(tsNode):    # if this is an index with a fixed number (whatever they are good for) .....
            tStamp = timeStampList[n] if utils.indexInRangeNeg(n, timeStampList) else None
            if (tStamp != None):
                slot = utils.getSlotFromTSAsDic(tStamp, ts) 
                slotC = SlotContainer(tStamp, slot, valueKey)
                resultSlice.append(slotC)
            return resultSlice
        else :
            # compute left & right boundary for n
            
            left  = self.getCurrentIndex(n, boundary["left"])
            right = self.getCurrentIndex(n, boundary["right"])          
            
            
            if (left > right):  # Iterate backwards over the slot.
                step=-1
            else:
                step=1
            
            while (42):
                tStamp = timeStampList[left] if utils.indexInRange(left, timeStampList) else None
                if (tStamp != None):
                    slotDic = utils.getSlotFromTSAsDic(tStamp, ts)
                    resultSlice.append(slotDic)
                
                #########################################
                left += step
                if left!=right:
                    break  
    
        # Apply boundary openess / closedness  
        resultSlice = resultSlice[1:] if (boundary["left"] =='OPEN') else resultSlice  # !!!! Attention. This seems wrong all over. Shouldn't it be boundary["left"][1]? 
        resultSlice = resultSlice[:-1] if (boundary["right"] =='OPEN') else resultSlice


        
        return (resultSlice, valueKey)




    
    def physical_slice(self, tsNode, ts, t, leftInfo, rightInfo):
        leftOffset=leftInfo["offset"]
        leftOffset=utils.normalizeTimeValue(leftOffset)
        
        rightOffset=rightInfo["offset"]
        rightOffset=utils.normalizeTimeValue(rightOffset)
        
        tLeft=t.asMilis()+leftOffset[0]    # Note, this assumes the same base unit for both. We need to enhance this like using the timestamp "add" routines
        tRight=t.asMilis()+rightOffset[0]
                
        tsLeft=TimeStamp(tLeft)
        tsRight=TimeStamp(tRight)
        
        
        ti=TimeInterval(TimeInterval.Openness.CLOSED, tsLeft, tsRight, TimeInterval.Openness.CLOSED)
    
    ##    public TimeSeries slice(TimeInterval intervall) throws NullPointerException;
        slice=ts.slice(ti)
    
        resultSlice=[]
        
        nodeType=tsNode[AST.TYPE]
        if nodeType=="PROPCOPY":
            valueKey="who cares"
        else: 
            valueKey = utils.getValueKey(tsNode, ts)
        
        allTS = slice.getTimeStampsArray()  # get ALL timestamps
        
        for tStamp in allTS:
            slotDic=utils.getSlotFromTSAsDic(tStamp, ts)
            resultSlice.append((tStamp, slotDic))   # Put the timestamp with the slot. We need it later.
       
       
        leftOpenness=leftInfo[AST.TYPE]
        rightOpenness=rightInfo[AST.TYPE]
 
        if leftOpenness=="OPEN" and len(resultSlice)>0 and resultSlice[0][0]==tsLeft: # if it fits exactly...
            del resultSlice[0]

        if rightOpenness=="OPEN" and len(resultSlice)>0 and resultSlice[-1][0]==tsRight: # again: if it fits exactly...
            del resultSlice[-1]
 
        # And now remove the timestamps
        for i in xrange(len(resultSlice)):
            resultSlice[i]=resultSlice[i][1]    
 
        return (resultSlice, valueKey)
    
    
    
    
    def evalTree(self, cRoot, timeStampList, tssDic, currentIndex, currentTime, spliceDic):
        ''' Recursive iteration through AST. Returns:
            A tuple ([dict], string) to code a slice. [dict] is the collection of slots in the slice.
            A dict to code a single slot. 
            A base type (string, int, ...) to code a skalar value 
        '''
        if isinstance( cRoot, dict ):
            type=cRoot[AST.TYPE];
            function=self.F3_OPERATIONS[type]
            result=function(self, cRoot, timeStampList, tssDic, currentIndex, currentTime, spliceDic)
            AST_Interpreter.logger.debug("Evaluated a tree of:\n%s" % (utils.F3TreeFormatter(cRoot, 0)))
            AST_Interpreter.logger.debug("Result is: %s" % str(result))
            return result 
    
        return cRoot




    
    def op_slice(self, ast_node, timeStampList, tssDic, currentIndex, currentTime, sliceDic):
        ''' Returns the entry of the current node (must be 'TS') from the dictionary of tsplices'''

        if not isinstance(ast_node, dict):
            raise Formula3Exception('Parameter must be an AST node of the type "dict". Received: '+typename(node))
        
        if ast_node[AST.TYPE] != AST.TYPE_SLICE:
            raise Formula3Exception('Parameter must be an AST node of the type \'SLICE\'. Received: '+str(node))

        tsname=ast_node["id"]
        timeSeriesInFocus=tssDic[tsname] # The time series we want to cut a slice off

        sliceInfo=ast_node["interval"]
        sliceType=sliceInfo[AST.TYPE]
        logical=(sliceType==AST.SLICE_TYPE_LOGICAL)
        if logical:
            (slice, valueKey) = self.logic_slice(ast_node, timeStampList, timeSeriesInFocus, currentIndex)
        else:
            
            leftInfo=sliceInfo["left"]   # nobody assures here that left is smaller than right, right? We'll cross that bridge when we come to it
            leftOffset=leftInfo["offset"]
            leftOffset=utils.normalizeTimeValue(leftOffset) # This should go into the parser (or the checker?) so it's done only once. Currently it's done here and during slicing
    
            rightInfo=sliceInfo["right"]
            rightOffset=rightInfo["offset"]
            rightOffset=utils.normalizeTimeValue(rightOffset)

            
            
            (slice, valueKey) = self.physical_slice(ast_node, timeSeriesInFocus, currentTime, leftInfo, rightInfo)   # This can be optimized by preparing the nodes to have normalized offset info

        
        if len(slice)==0:
            return None
        
        if len(slice)==1:   # it's just a single slot...
            slot=slice[0]
            return (slot, valueKey)
        
        return (slice, valueKey)
        
        
        
    
    
    
    
    
    def op_BINOP(self, node, timeStampList, tssDic, currentIndex, currentTime, spliceDic):
        '''
        Any binary operation.
        @param node: AST node, expected layout of members: ('BINOP', <operator>, <term1>, <term2>) 
        @param spliceDic: dictionary of current splices 
        @todo: change this method, it is horrible. also: implement multiple slots in a splice!
        '''
        operation=node["operation"]
        term1 = self.evalTree(node["left"], timeStampList, tssDic, currentIndex, currentTime, spliceDic)
        term2 = self.evalTree(node["right"], timeStampList, tssDic, currentIndex, currentTime, spliceDic)
                
        # Unwind operands and reduce them to datatypes that python can deal with
        if isinstance(term1, tuple) and isinstance(term1[0], list):  # a slice
            raise Forula3Exception("Can't do a binary operation on a slice")         
        if isinstance(term1, tuple): # Can only be a slot now
            slot=term1[0]
            vk=term1[1]
            op1=slot[vk]
        else:
            op1=term1
                
        if isinstance(term2, tuple) and isinstance(term2[0], list):  # a slice
            raise Forula3Exception("Can't do a binary operation on a slice")         
        if isinstance(term2, tuple): # Can only be a slot now
            slot=term2[0]
            vk=term2[1]
            op2=slot[vk]
        else:
            op2=term2
    
        if op1==None or op2==None:
            result=None
        else:
            binop_funcs={ 
                         'ADD' : lambda a, b: a+b,
                         'SUB' : lambda a, b: a-b,
                         'MUL' : lambda a, b: a*b,
                         'DIV' : lambda a, b: a/b,
                         'POW' : lambda a, b: a ** b,
                         'GT'  : lambda a, b: a > b,
                         'LT'  : lambda a, b: a < b,
                         'GTE' : lambda a, b: a >= b,
                         'LTE' : lambda a, b: a <= b,
                         'EQ'  : lambda a, b: a == b,
                         'NEQ' : lambda a, b: a != b,
                         'AND' : lambda a, b: (a!=0) and (b!=0),        # About the outlandish (a!=0) construct: 
                                                                        # Python gives back the first value if it is "True") so it would return
                                                                        # a and not "True" in case things work fine. We prevent this and force python to give back logical values.
                                                                        # Note: This is an arbitrary decision without being discussed. F3 might be better off otherwise.
                                                                        # ToDo: Discuss this. ToDo2: Will this work with Strings?
                         'OR'  : lambda a, b: (a!=0) or (b!=0),
                         'XOR' : lambda a, b: ((a!=0) and not b) or (not a and (b!=0))
                        }
            if not operation in binop_funcs:
                raise Formula3Exception("Unknown binary operation: "+operation)
            
            
            resultFunc=binop_funcs[operation]
            result=resultFunc(op1, op2)
    
    # This little hack makes sure that any operation done on int's gives back an int result.
    # Can anybody tell me ...
    # a) Why this is necessary?
    # b) why this isn't the case automatically? 
        if (type(op1) == int) and (type(op2) == int) and ((type(result) == int) == False):
            result = int(result)

        if isinstance(term1, tuple): # Can only be a slot now        
            new_slot = copy.copy(term1[0])
            vk=term1[1]
            new_slot[vk]=result
            AST_Interpreter.logger.debug("The result is %s " % (new_slot))
            return (new_slot, vk)
        
        elif isinstance(term2, tuple):        
            new_slot = copy.copy(term2[0])
            vk=term2[1]
            new_slot[vk]=result
            AST_Interpreter.logger.debug("The result is %s " % (new_slot))
            return (new_slot, vk)

        else:
            AST_Interpreter.logger.debug("The result is %s " % (result))
            return result





    def op_IFOT(self, node, timeStampList, tssDic, currentIndex, currentTime, spliceDic):
        '''
        If-otherwise operation.
        @param node: AST node, expected layout of members: ('IFOT', 'condition', 'true', 'false') 
        @param spliceDic: dictionary of current splices 
        '''
        conditionExpression=node["condition"]
        trueCondition=node["true"]
        falseCondition=node["false"]
        
        condition_result = self.evalTree(conditionExpression, timeStampList, tssDic, currentIndex, currentTime, spliceDic)
        
        if isinstance(condition_result, tuple) and isinstance(condition_result[0], list):   # A slice
            raise FormulaException("Can't use if/other with a slice.")

        if isinstance(condition_result, tuple):
            slot=condition_result[0]
            valueKey=condition_result[1]
            condition_result_skalar = slot[valueKey]
        else:
            condition_result_skalar=condition_result

        if condition_result_skalar:
            result = self.evalTree(trueCondition, timeStampList, tssDic, currentIndex, currentTime, spliceDic)
        else:
            result = self.evalTree(falseCondition, timeStampList, tssDic, currentIndex, currentTime, spliceDic)

        if isinstance(result, tuple) and isinstance(result[0], list):   # A slice
            raise FormulaException("Can't use if/other with a slice.")
        if isinstance(result, tuple):
            slot=result[0]
            valueKey=result[1]
            result = slot[valueKey]

        if result==None:    # We had the None-keyword in it?
            return None

        # otherwise construct a slot container
        if isinstance(condition_result, tuple):
            new_slot = copy.copy(condition_result[0])
            valueKey=condition_result[1]                    
            new_slot[valueKey] = result
            return (new_slot, valueKey)
        else:
            return result
    
    
    def op_UMINUS(self, node, timeStampList, tssDic, currentIndex, currentTime, spliceDic):
        operand=node["operand"]
        result=self.evalTree(operand, timeStampList, tssDic, currentIndex, currentTime, spliceDic)
        if isinstance(result, tuple) and isinstance(result[0], list): # a slice
            raise Formula3Exception("Can't negate a slice")
        
        
        if not isinstance(result, tuple):
            return -result # stupid name for the variable
        
        # it's a slot
        slot=result[0]
        vk=result[1]
        
        new_slot={}
        for k,v in slot.iteritems():
            new_slot[k]=-v
        
        return (new_slot, vk)




    def op_PROPCOPY(self, ast_node, timeStampList, tssDic, currentIndex, currentTime, spliceDic):

        if not isinstance(ast_node, dict):
            raise Formula3Exception('Parameter must be an AST node of the type "PROPCOPY". Received: '+typename(ast_node))
        
        if ast_node[AST.TYPE] != AST.TYPE_PROPCOPY:
            raise Formula3Exception('Parameter must be an AST node of the type \'PROPCOPY\'. Received: '+str(ast_node))

        tsname=ast_node["id"]
        timeSeriesInFocus=tssDic[tsname] # The time series we want to cut a slice off

        sliceInfo=ast_node["interval"]
        sliceType=sliceInfo[AST.TYPE]
        logical=(sliceType==AST.SLICE_TYPE_LOGICAL)
        if logical:
            (slice, valueKey) = self.logic_slice(ast_node, timeStampList, timeSeriesInFocus, currentIndex)
        else:
            
            leftInfo=sliceInfo["left"]   # nobody assures here that left is smaller than right, right? We'll cross that bridge when we come to it
            leftOffset=leftInfo["offset"]
            leftOffset=utils.normalizeTimeValue(leftOffset) # This should go into the parser (or the checker?) so it's done only once. Currently it's done here and during slicing
    
            rightInfo=sliceInfo["right"]
            rightOffset=rightInfo["offset"]
            rightOffset=utils.normalizeTimeValue(rightOffset)

            
            
            (slice, valueKey) = self.physical_slice(ast_node, timeSeriesInFocus, currentTime, leftInfo, rightInfo)   # This can be optimized by preparing the nodes to have normalized offset info



        
        if len(slice)==0:       # This can happen when there is no slot to copy. This in turn can happen e.g. with an every clause that is not covered by data completely
            raise Formula3Exception("No slot for propcopy found")

        slot=slice[0]           # We have at least one slot in the slice as len(slice)>0
        regexp=ast_node["REGEXP"]
        regexp="^"+regexp+"$"   # Force match of complete string. Is this really what we want?
        cRE=re.compile(regexp)

        result={}

        for name, value in slot.iteritems():
            mo=cRE.match(name)
            if mo!=None:
                result[name]=value
        
        return (result, valueKey)
        

    def op_PROPCOPY_names(self, node, tssDic):
        
        id=node["id"]
        ts=tssDic[id]
        
        valueKeys=ts.getTSProperty(TimeSeries.VALUE_KEYS)
        
        regexp=node["REGEXP"]
        regexp="^"+regexp+"$"   # Force match of complete string. Is this really what we want?
        cRE=re.compile(regexp)

        result=[]

        for name in valueKeys:
            mo=cRE.match(name)
            if mo!=None:
                result.append(name)
        
        return result


    def op_FuncCall(self, node, timeStampList, tssDic, currentIndex, currentTime, sliceDic):
        func_name = node[AST.ID]
        arg_list=node[AST.ARG_LIST]
        argument=arg_list[0]    # At the moment we do only support one function argument and it MUST be a literal right now. We'll change this pretty soon

        argument_result=self.evalTree(argument, timeStampList, tssDic, currentIndex, currentTime, sliceDic)


        if not func_name in formula3.globals.aggregates:
            if self.logger!=None:
                self.logger.error('Unsupported function '+func_name)
            raise Formula3Exception('Unsupported function '+func_name)
        
        operator = formula3.globals.aggregates[func_name]
        
        
        if isinstance(argument_result, tuple) and isinstance(argument_result[0], dict):
            argument_result=([argument_result[0]], argument_result[1])  # repack it as a slice. That makes calculating of aggregates easier. But this should be a temporary solution. 

        if isinstance(argument_result, tuple):  
            slice=argument_result[0]
            valueKey =argument_result[1]
            sliceInfo=(slice, valueKey, currentTime, None)  # What's the fourth argument needed for? 
            result=operator.calc(sliceInfo)
            return result
                        
        if argument_result==None:   # No idea whether "none" should call calc or calcAsFunction so this is arbitrary. This must be unified one of these days
            sliceInfo=(None, None, None, None)
            result=operator.calc(sliceInfo)
            return result
            
        result=operator.calcAsFunction(argument_result)
        
        return result




    F3_OPERATIONS = {
                     'IFOT'             : op_IFOT,
                     'BINOP'            : op_BINOP,
                     AST.TYPE_SLICE     : op_slice,
                     'UMINUS'           : op_UMINUS,
                     'PROPCOPY'         : op_PROPCOPY,
                     AST.TYPE_FUNCCALL  : op_FuncCall,
                     }






    ##############################################
    ## This is where processing starts          ##
    ##############################################
        
    def interprete( self, cRoot, tssDic, tsClass=None):
        ''' 
        Find the correct "operator" and process the AST
        @param cRoot: the current root of the AST
        @param tssDic: dictionary of input TimeSeries
        @param tsClass. If given controls the class of the timeseries given back. Otherwise a default will be used.
        @return: Result of AST interpretation (TimeSeries)
        '''
        
        AST_Interpreter.logger.debug("Calculating a tree of:\n%s" % (utils.F3TreeFormatter(cRoot, 0)))        
        if isinstance( cRoot, dict ): # Tree must be well-formed
            if cRoot[AST.TYPE] == 'generator' :
                result=self.op_generator(cRoot, tssDic, tsClass)
                return result

        raise Formula3Exception('Expected operator definition. Received '+`cRoot`)


    def evalTreeResultNames(self, expression, tssDic):
        ''' This is an expression. Try to evaluate the property name the result is assigned to.
            This is done by walking the tree and guess the name. If two names occur (in a bin op of an if or so) choose the leftmost one. 
        '''
        
        if not isinstance(expression, dict):    # Hey, it's a literal
            return []
        
        type=expression[AST.TYPE]
        if type=="BINOP":
            left =expression["left"]
            right=expression["right"]
            leftResult =self.evalTreeResultNames(left, tssDic)
            rightResult=self.evalTreeResultNames(right, tssDic)
            if isinstance(leftResult, list) and isinstance(rightResult, list):
                utils.updateListDecently(leftResult, rightResult)
                rightResult=None
            
            if isinstance(leftResult, str) and isinstance(rightResult, list):
                leftResult=utils.updateListDecently([leftResult], rightResult)
                rightResult=None
            
            return leftResult



        if type==AST.TYPE_FUNCCALL:
            
            arg_list=expression[AST.ARG_LIST]
            leading_expression=arg_list[0]  # Must be exactly one member in the list currently. This will change  (I hope)

            argResult=self.evalTreeResultNames(leading_expression, tssDic)
            
            id=expression[AST.ID]
            operator = formula3.globals.aggregates[id]
            valueKeys=operator.getValueKeys(argResult)
            
            return valueKeys
            
        
        if type==AST.TYPE_SLICE:
            # if an explicit property is given, the result will be written back to it
            # if no explicit key is given: find the default value key
            
#            property=expression['property']
#            if property!='':
#                return [property]

            tsName=expression[AST.ID]
            ts=tssDic[tsName]

            valueKey=utils.getValueKey(expression, ts)
            return [valueKey]
            
            

        if type=="IFOT":
            true_ex = expression["true"]
            false_ex= expression["false"]
            #Note: As the condition does not contribute to the result it is not evaluated
            true_result =self.evalTreeResultNames(true_ex, tssDic)
            false_result=self.evalTreeResultNames(false_ex, tssDic)
            if isinstance(true_result, str):
                true_result=[true_result]
            if isinstance(false_result, str):
                false_result=[false_result]
                
            utils.updateListDecently(true_result, false_result)
            
            return true_result
        
        if type=="PROPCOPY":
            result=self.op_PROPCOPY_names(expression, tssDic)
            return result
        
        if type=="UMINUS":
            expr=expression["operand"]
            result =self.evalTreeResultNames(expr, tssDic)
            return result

        raise Formula3Exception("unknown operation type %s " % (type, ))




    def constructResultTS(self, generator, tssDic, tsClass):
        baseTSNodeName = utils.findFirstTSName(generator)    # This TS governs the layout pattern of the output. This is a pragmatic approach until we find something different
        baseTS     = tssDic[baseTSNodeName]
    
        resultTS   = utils.createTimeSeries(baseTS, tsClass) # Create a timeseries using the basisTS as a template
    
        valueKeys  = utils.getEmptyStringArray()
        resultTS.setTSProperty(TimeSeries.DEFAULT, 0)   # This is per decree. His royal highness Gerhard has spoken

        # Now that we have constructed the hull time series fill it with the valueKeys
        expressionList=generator["expressions"] # The list of all expressions (separated by semicolon in the f3 string)     
        for expressionInfo in expressionList: 
            expression=expressionInfo[0]
            assignName=expressionInfo[1]
            
            result=[]
            
            if isinstance(expression , dict):   # it could also be a constant                                
                result = self.evalTreeResultNames(expression, tssDic)    # Result is either a list (then no assignment is needed) or a string

            if isinstance(result, unicode): # If the value keys are provided by java they come as unicode. Break this down to a normal str
                result=result.encode("utf-8")

            if len(result)>1 and assignName!=None:
                raise Formula3Exception("You can't use assign names with an aggregate which gives back more than one field")

            if result==[]: 
                if assignName==None:   # neither did it evaluate nor was an assign name given
                    raise Formula3Exception("If you use a constant expression you MUST give an assign name")
                else:
                    result=[assignName]

            if assignName!=None:    # There is an assign name and we tested every error mode up to here. Override the result with the assign name
                result=[assignName] 
                
            if not isinstance(result, list):    # Note, we should have converted any string that might have been given back into a list meanwhile. So this test is safe
                raise Formula3Exception("The expression %s gave back something strange: %s:%s" % (str(expression), type(result).__name__, str(result)))
                
            print "Updating the existing list " + str(valueKeys) + "with " + str(result)
            
            utils.updateListDecently(valueKeys, result)

        resultTS.setTSProperty(TimeSeries.VALUE_KEYS, valueKeys)    # Start with a virgin TS
        
        return resultTS
    
    
    

    def evaluate(self, ast, tss_in, tsClass=None, logger=None):
        '''
        Execute a Formula3 expression on a list of TimeSeries
        @param f3expression: Formula3 expression
        @param tss_in: A list of TimeSeries 
        @returns:  a TimeSeries
        Note: This needs a lot re-working as it is far from the intended result but ... (shrug) ... we need to make baby steps to understand this thoroughly 
        '''
        AST_Interpreter.logger.debug("evaluating the tree %s with the following time series: \n%s" % (utils.F3TreeFormatter(ast, 0), str(tss_in)))
        tssDic = tss_in
        
        type=ast[AST.TYPE] # Should always be stmt. Do we need to verify this?
        parameters=ast["parameters"]
        generators=ast["generators"]
        
        for generator in generators:
            tsResult = self.constructResultTS(generator, tssDic, tsClass)
            tsResult = self.interprete(generator, tssDic, tsResult)  # Run one pipe
            tssDic = {"_": tsResult}   # We feed the result back into the dictionary of time series under the special name "_" and thus make it available for the next iteration
        # -----------------------------------------------------------------------------------------------------------------                 
        return tsResult                             # Once we fall out of the loop the last tsResult is what we are looking for


    
    
