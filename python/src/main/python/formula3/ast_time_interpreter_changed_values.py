import AST

from formula3.exceptions.exception import Formula3Exception

try:
    from at.ac.ait.enviro.tsapi.timeseries import TimeStamp
except ImportError:
    print "Unable to import TimeStamps from java"
    from formula3.PythonTimeStamp import TimeStamp
    
try:
    from at.ac.ait.enviro.tsapi.timeseries import TimeInterval
except ImportError:
    print "Unable to import TimeInterval from Java"
    from formula3.PythonTimeInterval import TimeInterval
    
import formula3.utils.utils as util

#class SlotContainer():
#    '''container for a TimeStamp and a dictionary representing a slot'''
#    
#    def __init__(self, timeStamp=None, slot={}, valueKey=None):
#        self.timeStamp = timeStamp
#        self.slot = slot
#        self.valueKey = valueKey
#   
def interprete(tsNode, timeStampList, timepattern):
    ''' 
    Creates a slice from a TimeInterval with "time" boundaries ('t')
    @param tsNode: AST node of the time interval        
    @param timeStampList: list with TimeStamps of the current TimeInterval
    @param time: time pattern
    @return: TimeInterval instance where changed values are in
    '''
    
    ntime = util.normalizeTimePattern(timepattern)
    
    tss = util.createTimeSeriesList(tsNode)
    noffsets = []
    for ts in tss:
        interval = ts['interval']
        left_offset = interval['left']['offset']
        right_offset = interval['right']['offset']
        noffsets.append(util.normalizeTimeValue(left_offset))
        noffsets.append(util.normalizeTimeValue(right_offset))
    
    nlefttimevalue = min(noffsets)
    nrighttimevalue = max(noffsets)    
    
    startValue = util.findHighTimeStamp(ntime, nrighttimevalue, timeStampList[0].asMilis())
    start = TimeStamp(startValue)
    endValue = util.findLowTimeStamp(ntime, nlefttimevalue, timeStampList[1].asMilis())
    end = TimeStamp(endValue)
    
    return TimeInterval(TimeInterval.Openness.CLOSED, start, end, TimeInterval.Openness.CLOSED)




class AST_time_interpreter_changed_values():
    '''
    Time interpreter for downstream and upstream time aspects in AST generated by the AST_Parser
    '''

    def __init__(self):
        '''
        Constructor
        '''
        
        
        
    def evaluate(self, ast, time_intervalDict):
        '''
        Find the needed TimeInterval from initial interval
        @param ast: Abstract Syntax Tree from parsed expression
        @param time_interval: TimeInterval instance where values have changed
        @return: TimeInterval instance where update needed
        '''
        
#        parameters=ast["parameters"]
#        for key in time_intervalDict.keys():
#            if key not in parameters:
#                raise Formula3Exception("Interval given for non-existing parameter "+key)
# Note: Error handling commented out for the time that the surrounding java implementation does not support the mapping feature properly.

        time_interval=time_intervalDict.values()[0]

        generator = ast['generators'][0]
        every = generator['every']
        if every==None:
            return time_interval    # This probably is a logical interval. "Probably" 'cause there might come a day when every is allowed with n. In that case this assumption will be wrong  
            
        expression = generator['expressions'][0]
        return interprete(expression, [time_interval.getStart(), time_interval.getEnd()], every)
